plugin.eu.fbk.rdfpro.rules.RuleProcessor.create.rules=\
\n@rules2         Emit the closure of input quads using a set of rules\
\n  [-r RULESETS] use comma separated list of RULESETs (rdfs, owl2rl, custom file)\
\n  [-B BINDINGS] use comma separated list of var=value BINDING to customize rules\
\n  [-p] MODE     set partitioning MODE: none (default), entity, graph, rules\
\n  [-g] MODE     set graph inference MODE: none (default), global, separate, star\
\n  [-G] URI      set global graph URI for inference modes global and star\
\n  [-t]          drop uninformative <x rdf:type _:b> statements (default: keep)\
\n  [-u]          emit unique statements (may be faster than separate @unique)\
\n  [-C | -c URI] emit static data closure unchanged [-C] or to graph URI [-c]\
\n  [-b URI][-w]  use base URI [-b] and BNode rewriting [-w] to load static data\
\n  [FILE...]     load static data (e.g., TBox) from FILE...\

rdfpro.rules.engine=eu.fbk.rdfpro.rules.drools.Engine$Builder
rdfpro.rules.rhodf=classpath:/eu/fbk/rdfpro/rules/rhodf.ttl
rdfpro.rules.rdfs=classpath:/eu/fbk/rdfpro/rules/rdfs.ttl
rdfpro.rules.horst=classpath:/eu/fbk/rdfpro/rules/horst.ttl
rdfpro.rules.owl2rl=classpath:/eu/fbk/rdfpro/rules/owl2rl.ttl
